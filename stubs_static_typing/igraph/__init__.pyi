from typing import Any, List, Tuple

def deprecated(message) -> None: ...

class Graph():
    omega: Any
    alpha: Any
    shell_index: Any
    cut_vertices: Any
    blocks: Any
    evcent: Any
    vertex_disjoint_paths: Any
    edge_disjoint_paths: Any
    cohesion: Any
    adhesion: Any
    shortest_paths_dijkstra: Any
    subgraph: Any
    def __init__(self, *args, **kwds) -> None: ...
    def add_edge(self, source, target, **kwds): ...
    def add_edges(self, es, attributes: Any | None = ...): ...
    def add_vertex(self, name: Any | None = ..., **kwds): ...
    def add_vertices(self, n, attributes: Any | None = ...): ...
    def as_directed(self, *args, **kwds): ...
    def as_undirected(self, *args, **kwds): ...
    def delete_edges(self, *args, **kwds): ...
    def indegree(self, *args, **kwds): ...
    def outdegree(self, *args, **kwds): ...
    def all_st_cuts(self, source, target): ...
    def all_st_mincuts(self, source, target, capacity: Any | None = ...): ...
    def biconnected_components(self, return_articulation_points: bool = ...): ...
    def clear(self) -> None: ...
    def cohesive_blocks(self): ...
    def clusters(self, mode: str = ...): ...
    components: Any
    def degree_distribution(self, bin_width: int = ..., *args, **kwds): ...
    def dyad_census(self, *args, **kwds): ...
    def get_adjacency(self, type=..., attribute: Any | None = ..., default: int = ..., eids: bool = ...): ...
    def get_adjacency_sparse(self, attribute: Any | None = ...): ...
    def get_adjlist(self, mode: str = ...): ...
    def get_all_simple_paths(self, v, to: Any | None = ..., cutoff: int = ..., mode: str = ...): ...
    def get_inclist(self, mode: str = ...): ...
    def gomory_hu_tree(self, capacity: Any | None = ..., flow: str = ...): ...
    def is_named(self): ...
    def is_weighted(self): ...
    def maxflow(self, source, target, capacity: Any | None = ...): ...
    def mincut(self, source: Any | None = ..., target: Any | None = ..., capacity: Any | None = ...): ...
    def st_mincut(self, source, target, capacity: Any | None = ...): ...
    def modularity(self, membership, weights: Any | None = ...): ...
    def path_length_hist(self, directed: bool = ...): ...
    def pagerank(self, vertices: Any | None = ..., directed: bool = ..., damping: float = ..., weights: Any | None = ..., arpack_options: Any | None = ..., implementation: str = ..., niter: int = ..., eps: float = ...): ...
    def spanning_tree(self, weights: Any | None = ..., return_tree: bool = ...): ...
    def transitivity_avglocal_undirected(self, mode: str = ..., weights: Any | None = ...): ...
    def triad_census(self, *args, **kwds): ...
    def count_automorphisms_vf2(self, color: Any | None = ..., edge_color: Any | None = ..., node_compat_fn: Any | None = ..., edge_compat_fn: Any | None = ...): ...
    def get_automorphisms_vf2(self, color: Any | None = ..., edge_color: Any | None = ..., node_compat_fn: Any | None = ..., edge_compat_fn: Any | None = ...): ...
    def community_fastgreedy(self, weights: Any | None = ...): ...
    def community_infomap(self, edge_weights: Any | None = ..., vertex_weights: Any | None = ..., trials: int = ...): ...
    def community_leading_eigenvector_naive(self, clusters: Any | None = ..., return_merges: bool = ...): ...
    def community_leading_eigenvector(self, clusters: Any | None = ..., weights: Any | None = ..., arpack_options: Any | None = ...): ...
    def community_label_propagation(self, weights: Any | None = ..., initial: Any | None = ..., fixed: Any | None = ...): ...
    def community_multilevel(self, weights: Any | None = ..., return_levels: bool = ...): ...
    def community_optimal_modularity(self, *args, **kwds): ...
    def community_edge_betweenness(self, clusters: Any | None = ..., directed: bool = ..., weights: Any | None = ...): ...
    def community_spinglass(self, *args, **kwds): ...
    def community_walktrap(self, weights: Any | None = ..., steps: int = ...): ...
    def k_core(self, *args): ...
    def community_leiden(self, objective_function: str = ..., weights: Any | None = ..., resolution_parameter: float = ..., beta: float = ..., initial_membership: Any | None = ..., n_iterations: int = ..., node_weights: Any | None = ...): ...
    def layout(self, layout: Any | None = ..., *args, **kwds): ...
    def layout_auto(self, *args, **kwds): ...
    def layout_sugiyama(self, layers: Any | None = ..., weights: Any | None = ..., hgap: int = ..., vgap: int = ..., maxiter: int = ..., return_extended_graph: bool = ...): ...
    def maximum_bipartite_matching(self, types: str = ..., weights: Any | None = ..., eps: Any | None = ...): ...
    def to_networkx(self, create_using: Any | None = ...): ...
    @classmethod
    def from_networkx(cls, g): ...
    def to_graph_tool(self, graph_attributes: Any | None = ..., vertex_attributes: Any | None = ..., edge_attributes: Any | None = ...): ...
    @classmethod
    def from_graph_tool(cls, g): ...
    def write_adjacency(self, f, sep: str = ..., eol: str = ..., *args, **kwds) -> None: ...
    @classmethod
    def Read_Adjacency(cls, f, sep: Any | None = ..., comment_char: str = ..., attribute: Any | None = ..., *args, **kwds): ...
    @classmethod
    def Adjacency(cls, matrix, mode: str = ..., *args, **kwargs): ...
    @classmethod
    def Weighted_Adjacency(cls, matrix, mode: str = ..., attr: str = ..., loops: bool = ...): ...
    def write_dimacs(self, f, source: Any | None = ..., target: Any | None = ..., capacity: str = ...): ...
    def write_graphmlz(self, f, compresslevel: int = ...) -> None: ...
    @classmethod
    def Read_DIMACS(cls, f, directed: bool = ...): ...
    @classmethod
    def Read_GraphMLz(cls, f, index: int = ...): ...
    def write_pickle(self, fname: Any | None = ..., version: int = ...): ...
    def write_picklez(self, fname: Any | None = ..., version: int = ...): ...
    @classmethod
    def Read_Pickle(cls, fname: Any | None = ...): ...
    @classmethod
    def Read_Picklez(cls, fname): ...
    def write_svg(self, fname, layout: str = ..., width: Any | None = ..., height: Any | None = ..., labels: str = ..., colors: str = ..., shapes: str = ..., vertex_size: int = ..., edge_colors: str = ..., edge_stroke_widths: str = ..., font_size: int = ..., *args, **kwds) -> None: ...
    @classmethod
    def Read(cls, f, format: Any | None = ..., *args, **kwds): ...
    Load: Any
    def write(self, f, format: Any | None = ..., *args, **kwds): ...
    save: Any
    @classmethod
    def DictList(cls, vertices, edges, directed: bool = ..., vertex_name_attr: str = ..., edge_foreign_keys=..., iterative: bool = ...): ...
    @classmethod
    def TupleList(cls, edges, directed: bool = ..., vertex_name_attr: str = ..., edge_attrs: Any | None = ..., weights: bool = ...): ...
    Formula: Any
    @property
    def vs(self): ...
    @property
    def es(self): ...
    @classmethod
    def Bipartite(cls, types, edges, directed: bool = ..., *args, **kwds): ...
    @classmethod
    def Full_Bipartite(cls, n1, n2, directed: bool = ..., mode: str = ..., *args, **kwds): ...
    @classmethod
    def Random_Bipartite(cls, n1, n2, p: Any | None = ..., m: Any | None = ..., directed: bool = ..., neimode: str = ..., *args, **kwds): ...
    @classmethod
    def GRG(cls, n, radius, torus: bool = ...): ...
    @classmethod
    def Incidence(cls, matrix, directed: bool = ..., mode: str = ..., multiple: bool = ..., weighted: Any | None = ..., *args, **kwds): ...
    @classmethod
    def DataFrame(cls, edges, directed: bool = ..., vertices: Any | None = ..., use_vids: bool = ...): ...
    def get_vertex_dataframe(self): ...
    def get_edge_dataframe(self): ...
    def bipartite_projection(self, types: str = ..., multiplicity: bool = ..., probe1: int = ..., which: str = ...): ...
    def bipartite_projection_size(self, types: str = ..., *args, **kwds): ...
    def get_incidence(self, types: str = ..., *args, **kwds): ...
    def dfs(self, vid, mode=...): ...
    def __iadd__(self, other): ...
    def __add__(self, other): ...
    def __and__(self, other): ...
    def __isub__(self, other): ...
    def __sub__(self, other): ...
    def __mul__(self, other): ...
    def __bool__(self): ...
    def __or__(self, other): ...
    def __coerce__(self, other): ...
    def __reduce__(self): ...
    __iter__: Any
    __hash__: Any
    def __plot__(self, context, bbox, palette, *args, **kwds) -> None: ...
    def summary(self, verbosity: int = ..., width: Any | None = ..., *args, **kwds): ...
    def disjoint_union(self, other): ...
    def union(self, other, byname: str = ...): ...
    def intersection(self, other, byname: str = ...): ...
    def is_directed(self)-> bool: ...
    def is_connected(self)-> bool: ...
    def vcount(self)-> int: ...
    def get_edgelist(self)->List[Tuple[int, int]]: ...

class VertexSeq():
    def attributes(self): ...
    def find(self, *args, **kwds): ...
    def select(self, *args, **kwds): ...
    def __call__(self, *args, **kwds): ...

class EdgeSeq():
    def attributes(self): ...
    def find(self, *args, **kwds): ...
    def select(self, *args, **kwds): ...
    def __call__(self, *args, **kwds): ...

def autocurve(graph, attribute: str = ..., default: int = ...): ...
def get_include(): ...
def read(filename, *args, **kwds): ...
load = read

def write(graph, filename, *args, **kwds): ...
save = write
config: Any
